#VRML_SIM R2025a utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# documentation url: https://webots.cloud/run?url=https://github.com/cyberbotics/webots/blob/released/projects/objects/solids/protos/SolidPipe.proto
# keywords: primitive/geometry
# A pipe object implemented at the Solid-node level.
# Graphically, the SolidPipe is an IndexedFaceSet.
# Physically, the SolidPipe is a set of N boxes, where N is the subdivision field.
# The 'accuracy' field defines how much boxes position can differ on z-axis: a 0 value represents an error-free model but it will slow down the simulation.
# template language: javascript


PROTO SolidPipe [
  field SFVec3f    translation           0 0 1
  field SFRotation rotation              0 0 1 0
  field SFString   name                  "pipe"
  field SFFloat    height                1.0 
  field SFFloat    radius                0.5 
  field SFFloat    thickness             0.05
  field SFInt32    subdivision           24 
  field SFFloat    accuracy              0.0001
  field SFString   contactMaterial       "default" 
  field SFNode     appearance            PBRAppearance { baseColorMap ImageTexture {
                                                           url [ "../worlds/textures/light_asphalt.jpg" ] }
                                                         metalness 0 roughness 0.5 }  
  field SFNode     physics               NULL      
  field SFBool     enableBoundingObject  TRUE     
]
{
  %<
    import * as wbgeometry from 'wbgeometry.js';

    // parameter checking
    let subdivision = fields.subdivision.value;
    if (subdivision > 200)
      console.log('High value for \'subdivision\'. This can slow down the simulation');

    if (subdivision < 8) {
      console.error('\'subdivision\' must be greater or equal to 8. Using 8 instead.');
      subdivision = 8;
    }

    let height = fields.height.value;
    if (height <= 0) {
      height = fields.height.defaultValue;
      console.error('\'height\' must be strictly positive. Value reset to ' + height + '.');
    }

    let radius = fields.radius.value;
    if (radius <= 0) {
      radius = fields.radius.defaultValue;
      console.error('\'radius\' must be strictly positive. Value reset to ' + radius + '.');
    }

    let thickness = fields.thickness.value;
    if (thickness <= 0) {
      thickness = radius * 0.5;
      console.error('\'thickness\' must be greater than 0. Value reset to ' + thickness + '.');
    } else if (thickness >= fields.radius.value) {
      thickness = radius * 0.5;
      console.error('\'thickness\' must be smaller than \'radius\'. Value reset to ' + thickness + '.');
    }

    // global stuff before entering in the main loop
    const beta = 2.0 * Math.PI / subdivision;
    const alpha = beta * 0.5;
    const innerRadius = radius - thickness;
    let su = radius * Math.cos(alpha) - innerRadius;
    if (su < 0) {
      console.error('Either \'thickness\' or \'subdivision\' are too small for the box subdivision algorithm.');
      su = Math.abs(su);
    }

    let offset0, offset1, offset2, offset3, offset4, offset5;
  >%
  Solid {
    translation IS translation
    rotation IS rotation
    children [
      Shape {
        appearance IS appearance
        geometry IndexedFaceSet {
          coord Coordinate {
            point [
              %<
                const outerCircle = wbgeometry.circle(radius, subdivision, {x: 0, y: 0}, - Math.PI * 0.5);
                const innerCircle = wbgeometry.circle(radius - su, subdivision, {x: 0, y: 0}, - Math.PI * 0.5);
              >%
              # top outer
              %< for (let i = 0; i < outerCircle.length; ++i) { >%
                %<= outerCircle[i].x >% %<= outerCircle[i].y >% %<= height * 0.5 >%
              %< } >%
              # top inner
              %< for (let i = 0; i < innerCircle.length; ++i) { >%
                %<= innerCircle[i].x >% %<= innerCircle[i].y >% %<= height * 0.5 >%
              %< } >%
              # bottom outer
              %< for (let i = 0; i < outerCircle.length; ++i) { >%
                %<= outerCircle[i].x >% %<= outerCircle[i].y >% %<= - height * 0.5 >%
              %< } >%
              # bottom inner
              %< for (let i = 0; i < innerCircle.length; ++i) { >%
                %<= innerCircle[i].x >% %<= innerCircle[i].y >% %<= - height * 0.5 >%
              %< } >%
            ]
          }
          texCoord TextureCoordinate {
            point [
              %<
                const innerTexCircle = wbgeometry.circle(0.5 * (radius - su) / radius, subdivision,
                                                         {x: 0.5, y: 0.5}, - Math.PI * 0.5)
                const outerTexCircle = wbgeometry.circle(0.5, subdivision,
                                                         {x: 0.5, y: 0.5}, - Math.PI * 0.5)
              >%
              # outer circle # vertically inverted
              %< for (let i = 0; i < outerTexCircle.length; ++i) { >%
                %<= outerTexCircle[i].x >% %<= - outerTexCircle[i].y >%
              %< } >%
              # inner circle # vertically inverted
              %< for (let i = 0; i < innerTexCircle.length; ++i) { >%
                %<= innerTexCircle[i].x >% %<= - innerTexCircle[i].y >%
              %< } >%
              # outer circle
              %< for (let i = 0; i < outerTexCircle.length; ++i) { >%
                %<= outerTexCircle[i].x >% %<= outerTexCircle[i].y >%
              %< } >%
              # inner circle
              %< for (let i = 0; i < innerTexCircle.length; ++i) { >%
                %<= innerTexCircle[i].x >% %<= innerTexCircle[i].y >%
              %< } >%
              # top band
              %< for (let i = 0; i <= subdivision; ++i) { >%
                %<= i / subdivision - 0.5 >% 1.0
              %< } >%
              # bottom band
              %< for (let i = 0; i <= subdivision; ++i) { >%
                %<= i / subdivision - 0.5  >% 0.0
              %< } >%
            ]
          }

          coordIndex [
            %<
              offset0 = 0;
              offset1 = subdivision + 1;
              offset2 = 2 * offset1;
              offset3 = 3 * offset1;
            >%
            # top
            %< for (let i = 0; i <= subdivision - 1; ++i) { >%
              %<= offset0 + i >% %<= offset0 + i + 1 >% %<= offset1 + i + 1 >% %<= offset1 + i >% -1
            %< } >%
            # bottom
            %< for (let i = 0; i <= subdivision - 1; ++i) { >%
              %<= offset2 + i >% %<= offset3 + i >% %<= offset3 + i + 1 >% %<= offset2 + i + 1 >% -1
            %< } >%
            # inner side
            %< for (let i = 0; i <= subdivision - 1; ++i) { >%
              %<= offset1 + i >% %<= offset1 + i + 1 >% %<= offset3 + i + 1 >% %<= offset3 + i >% -1
            %< } >%
            # outer side
            %< for (let i = 0; i <= subdivision - 1; ++i) { >%
              %<= offset0 + i >% %<= offset2 + i >% %<= offset2 + i + 1 >% %<= offset0 + i + 1 >% -1
            %< } >%
          ]

          creaseAngle 1.5
        }
      }
    ]
    name IS name
    model "pipe"
    contactMaterial IS contactMaterial
  }
}
